{
    "componentChunkName": "component---src-templates-blog-template-js",
    "path": "/JAVA/Spring2/",
    "result": {"data":{"cur":{"id":"bdf14ca3-10e2-5a47-9931-bf68222b70fa","html":"<h2 id=\"1-spring-boot-동작-방식\" style=\"position:relative;\"><a href=\"#1-spring-boot-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\" aria-label=\"1 spring boot 동작 방식 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Spring Boot 동작 방식</h2>\n<p>스프링 부트에서 Spring-boot-starter-web 모듈을 사용하면 기본적으로 Tomcat을 사용하는 스프링 MVC 구조를 기반으로 동작합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 720px; \"\n    >\n      <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 56.111111111111114%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAIAAADwazoUAAAACXBIWXMAABJ0AAASdAHeZh94AAAA6ElEQVQoz5VSi26DMAzk/39ym0bJa5UIhELw+VIBRWISnZilWI6TS3xnV+W3sZCF5ZpVxw0oSoAiKqWwrr+ds5fALFRiCUgs4GKam3PmdXpW0AHMHby/ouv9lztjVMW+DcG3sW27TgBvnbMG1HGa6lttTDNOYxb5+vywtkHRLPP9/uOcVaJKjxS7mIY0Q6AwTeO9BwGFtc4HP82zUq01IXiWIkDXd7GLSj3jvAakLosUYMyZK+nF/SXYQmsTjH1KwzCwqGAOwW+lvm2VElursP46S86S1wweQ0p9hL4HHyVdgz13ZUj+a0+mNohWopAggwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"Spring_1.png\"\n        title=\"Spring_1.png\"\n        src=\"/static/fe66a4e4327cc39c980968927d4a9afe/37523/Spring_1.png\"\n        srcset=\"/static/fe66a4e4327cc39c980968927d4a9afe/e9ff0/Spring_1.png 180w,\n/static/fe66a4e4327cc39c980968927d4a9afe/f21e7/Spring_1.png 360w,\n/static/fe66a4e4327cc39c980968927d4a9afe/37523/Spring_1.png 720w,\n/static/fe66a4e4327cc39c980968927d4a9afe/302a4/Spring_1.png 1080w,\n/static/fe66a4e4327cc39c980968927d4a9afe/6be49/Spring_1.png 1160w\"\n        sizes=\"(max-width: 720px) 100vw, 720px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n    </span></p>\n<p>서블릿 : 클라이언트의 요청을 처리하고 결과를 반환하는 자바 웹 프로그래밍 기술</p>\n<p>서블릿 컨테이너 : HTTP 요청을 받아 웹페이지를 동적으로 생성하는 역할을 합니다.\r\n서블릿 인스턴스를 생성하고 관리하는 역할을 수행하는 주체,\r\nEx) Tomcat</p>\n<p>서블릿 컨테이너의 특징</p>\n<ul>\n<li>서블릿 객체를생성, 초기화, 호출, 종료하는 생명주기 관리</li>\n<li>서블릿 객체는 싱글톤 패턴으로 관리</li>\n<li>멀티 스레딩 지원</li>\n</ul>\n<p>스프링에서는 DispatcherServlet이 서블릿의 역할을 수행합니다. 서블릿 컨테이너와 DispatcherServlet은 자동 설정된 web.xml의 설정값을 공유합니다.</p>\n<p>동작 원리</p>\n<ol>\n<li>\n<p>DispatcherServlet으로 요청(HttpServletRequest)이 들어오면 DispatcherServlet은 핸들러 매핑을 통하 요청 URI에 매핑된 핸들러를 탐색합니다.</p>\n</li>\n<li>\n<p>핸들러어댑터로 컨트롤러를 호출합니다.</p>\n</li>\n<li>\n<p>핸들러 업댑터에 컨트롤러의 응답으 돌아오면 ModelAndView로 응답을 가공해 반환합니다.</p>\n</li>\n<li>\n<p>뷰 형식으로 리턴하는 컨트롤러를 사용할 때는 뷰 리졸버를 통해 뷰를 받아 리턴합니다.</p>\n</li>\n</ol>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1-spring-boot-%EB%8F%99%EC%9E%91-%EB%B0%A9%EC%8B%9D\">1. Spring Boot 동작 방식</a></li>\n</ul>\n</div>","excerpt":"1. Spring Boot 동작 방식 스프링 부트에서 Spring-boot-starter-web 모듈을 사용하면 기본적으로 Tomcat을 사용하는 스프링 MVC 구조를 기반으로 동작합니다.  서블릿 : 클라이언트의 요청을 처리하고 결과를 반환하는 자바 웹 프로그래밍 기술 서블릿 컨테이너 : HTTP 요청을 받아 웹페이지를 동적으로 생성하는 역할을 합니다.\r\n서블릿 인스턴스를 생성하고 관리하는 역할을 수행하는 주체,\r\nEx) Tomcat 서블릿 컨테이너의 특징 서블릿 객체를생성, 초기화, 호출, 종료하는 생명주기 관리 서블릿 객체는 싱글톤 패턴으로 관리 멀티 스레딩 지원 스프링에서는 DispatcherServlet이 서블릿의 역할을 수행합니다. 서블릿 컨테이너와 DispatcherServlet은 자동 설정된 web.xml의 설정값을 공유합니다. 동작 원리 DispatcherServlet으로 요청(HttpServletRequest)이 들어오면 DispatcherServlet은 핸들러 …","frontmatter":{"date":"September 01, 2022","title":"JAVA Spring Study 2","categories":"Develop","author":"KORWOO","emoji":"🔮"},"fields":{"slug":"/JAVA/Spring2/"}},"next":{"id":"ed35f9d8-70fe-51e8-afc7-f9473e92474b","html":"<h2 id=\"1-spring의-특징\" style=\"position:relative;\"><a href=\"#1-spring%EC%9D%98-%ED%8A%B9%EC%A7%95\" aria-label=\"1 spring의 특징 permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>1. Spring의 특징</h2>\n<ol>\n<li>제어 역전(IoC)</li>\n</ol>\n<p>제어 역전(Inversion of Control) 을 특징으로 하는 스프링은 기존 자바 개발 방식과 다르게 작동합니다.\r\nIoC를 적용한 환경에서는 사용할 객체를 직접 생성하지 않고 객체의 생명주기 관리를 외부에 위임합니다.\r\n외부는 스프링 컨테이너, IoC 컨테이너를 의미합니다.</p>\n<p>객체의 관리를 외부에 맡겨 제어권이 넘어간 것을 제어 역전이라고 하며, 제어 역전을 통해 의존성 주입(Dependency injection),\r\n관점 지향 프로그래밍(Aspect_Oriented Programming) 등이 가능해집니다.</p>\n<ol start=\"2\">\n<li>의존성 주입(DI)</li>\n</ol>\n<p>의존성 주입(Dependency Injection)이란 제어 역전의 방법 중 하나로, 사용할 객체를 직접 생성하지 않고 외부 컨테이너가 생성한 객체를 주입받아\r\n사용하는 방식을 의미합니다.</p>\n<ul>\n<li>의존성 주입방법</li>\n</ul>\n<p>2-1.  생성자를 통한 의존성 주입</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RestController</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">DIController</span>\r\n<span class=\"token punctuation\">{</span>\r\n  <span class=\"token class-name\">MyService</span> myService<span class=\"token punctuation\">;</span>\r\n  <span class=\"token annotation punctuation\">@Autowired</span>\r\n  <span class=\"token keyword\">public</span> <span class=\"token class-name\">DIController</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">Myservice</span> myService<span class=\"token punctuation\">)</span>\r\n    <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>myService<span class=\"token operator\">=</span>myService<span class=\"token punctuation\">;</span>\r\n    <span class=\"token punctuation\">}</span>\r\n\r\n      <span class=\"token annotation punctuation\">@GetMapping</span><span class=\"token punctuation\">(</span><span class=\"token string\">\"/di/hello\"</span><span class=\"token punctuation\">)</span>\r\n      <span class=\"token keyword\">public</span> <span class=\"token class-name\">String</span> <span class=\"token function\">hetHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span>\r\n      <span class=\"token punctuation\">{</span>\r\n        <span class=\"token keyword\">return</span> myService<span class=\"token punctuation\">.</span><span class=\"token function\">getHello</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\r\n      <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span></code></pre></div>\n<p>2-2.  필드 객체 선언을 통한 의존성 주입</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RestController</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">FieldInjectionController</span>\r\n<span class=\"token punctuation\">{</span>\r\n  <span class=\"token annotation punctuation\">@Autowired</span>\r\n  <span class=\"token keyword\">private</span> <span class=\"token class-name\">MyService</span> myService<span class=\"token punctuation\">;</span>\r\n<span class=\"token punctuation\">}</span>\r\n</code></pre></div>\n<p>2-3.  setter 메서드를 통한 의존성 주입</p>\n<div class=\"gatsby-highlight\" data-language=\"java\"><pre class=\"language-java\"><code class=\"language-java\"><span class=\"token annotation punctuation\">@RestController</span>\r\n<span class=\"token keyword\">public</span> <span class=\"token keyword\">class</span> <span class=\"token class-name\">SetterInjectionController</span>\r\n<span class=\"token punctuation\">{</span>\r\n  <span class=\"token class-name\">MyService</span> myService<span class=\"token punctuation\">;</span>\r\n\r\n  <span class=\"token annotation punctuation\">@Autowired</span>\r\n  <span class=\"token keyword\">public</span> <span class=\"token keyword\">void</span> <span class=\"token function\">setMyService</span><span class=\"token punctuation\">(</span><span class=\"token class-name\">MyService</span> myService<span class=\"token punctuation\">)</span>\r\n  <span class=\"token punctuation\">{</span>\r\n    <span class=\"token keyword\">this</span><span class=\"token punctuation\">.</span>myService<span class=\"token operator\">=</span>myService<span class=\"token punctuation\">;</span>\r\n  <span class=\"token punctuation\">}</span>\r\n<span class=\"token punctuation\">}</span>\r\n</code></pre></div>\n<ol start=\"3\">\n<li>관점 지향 프로그래밍(AOP)</li>\n</ol>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">관점 지향 프로그래밍(Aspect-Oriented Programming)은 스프링의 아주 중요한 특징입니다.\r\nAOP는 관점을 기준으로 묶어 개발하는 방식을 의미합니다. 관점이란 어떤 기능을 구현할 때 그 기능을 핵심기능과 부가기능으로 구분하여\r\n각각을 하나의 관점으로 보는 것을 의미합니다.\r\n\r\n핵심기능은 비즈니스 로직을 구현하는 과정에서 비즈니스 로직이 처리하려는 목적 기능을 말합니다.\r\nEx) 클라이언트로부터 상품 정보 등록 요청을 받아 DB에 저장, 그 상품 정보를 조회하는 비즈니스 로직을 구현한다면, 핵심기능은\r\n1) 상품 정보를 DB에 저장하고,\r\n2) 저장된 상품 정보 데이터를 보여주는 코드\r\n입니다.\r\n\r\n여기서 핵심 기능에 부가 기능을 추가해야 하는 상황이 발생할 수 있습니다.\r\n핵심 기능인 비즈니스 로직 사이에 로깅 처리를 하거나 트랜잭션을 처리하는 코드가 예시입니다.\r\n\r\n![OOP_Logic.png](OOP_Logic.png)\r\n\r\n객체 지향 방식의 애플리케이션 로직에서는 위의 그림과 같이 객체마다 핵심 기능을 수행하기 위한 로직과 함께 부가 기능인 로깅, 트랜잭션 등의\r\n코드를 작성합니다. '상품 정보 등록' 과 '상품 정보 조회' 는 엄연히 다른 기능으로 각자 로직이 구현되어 있습니다.\r\n하지만 동일한 기능을 수행할 확률이 높습니다. 즉, 핵심기능을 구현한 두 로직에 동일한 코드가 포함됨을 의미합니다.\r\n\r\n![AOP_LOGIC.png](AOP_LOGIC.png)\r\n\r\nAOP의 관점에서는 부가 기능은 핵심 기능이 어떤 기능인지에 무관하게 로직이 수행되기 전 또는 후에 수행되기만 하면 됩니다.</code></pre></div>\n<div class=\"table-of-contents\">\n<ul>\n<li><a href=\"#1-spring%EC%9D%98-%ED%8A%B9%EC%A7%95\">1. Spring의 특징</a></li>\n</ul>\n</div>","frontmatter":{"date":"August 29, 2022","title":"JAVA Spring Study 1","categories":"Develop","author":"KORWOO","emoji":"🔮"},"fields":{"slug":"/JAVA/Spring1/"}},"prev":null,"site":{"siteMetadata":{"siteUrl":"https://www.zoomkoding.com","comments":{"utterances":{"repo":""}}}}},"pageContext":{"slug":"/JAVA/Spring2/","nextSlug":"/JAVA/Spring1/","prevSlug":""}},
    "staticQueryHashes": ["1073350324","1956554647","2938748437"]}